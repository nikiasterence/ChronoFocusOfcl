<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Gridora - Liquid Moodboard</title>
    <style>
        /* === RESET & BASE === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Apple Liquid Glass Colors */
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.3);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            --glass-blur: blur(20px);
            
            /* Theme Colors */
            --primary: #007AFF;
            --secondary: #5856D6;
            --success: #34C759;
            --danger: #FF3B30;
            --warning: #FF9500;
            
            /* Backgrounds */
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --canvas-bg: #f5f5f7;
            
            /* Typography */
            --font-primary: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Animation */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-smooth: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            
            /* Border Radius */
            --radius-sm: 12px;
            --radius-md: 16px;
            --radius-lg: 20px;
            --radius-xl: 24px;
            --radius-full: 50%;
        }

        body {
            font-family: var(--font-primary);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: var(--bg-gradient);
            position: relative;
        }

        /* === LIQUID GLASS COMPONENTS === */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            border-radius: var(--radius-md);
        }

        .glass-dark {
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--glass-shadow);
            border-radius: var(--radius-md);
            color: white;
        }

        /* === LAYOUT === */
        #app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* === HEADER === */
        #header {
            padding: var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-md);
            z-index: 1000;
            flex-shrink: 0;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            letter-spacing: -0.5px;
        }

        .header-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            flex-wrap: wrap;
        }

        /* === BUTTONS === */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius-xl);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #1d1d1f;
        }

        .btn-icon {
            padding: 10px;
            min-width: 40px;
            justify-content: center;
            border-radius: var(--radius-full);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* === CANVAS === */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            margin: 0 var(--spacing-md) var(--spacing-md);
            border-radius: var(--radius-lg);
            background: var(--canvas-bg);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        #canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: center;
            cursor: grab;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        #canvas.dot-grid {
            background-image: radial-gradient(circle, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* === CANVAS ITEMS === */
        .canvas-item {
            position: absolute;
            cursor: move;
            transition: box-shadow var(--transition-fast);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            border-radius: var(--radius-md);
        }

        .canvas-item.selected {
            box-shadow: 0 0 0 3px var(--primary), 0 8px 24px rgba(0, 122, 255, 0.3);
            z-index: 9999 !important;
        }

        .canvas-item.dragging {
            opacity: 0.8;
            cursor: grabbing;
        }

        /* Image Item */
        .item-image {
            overflow: hidden;
            border-radius: var(--radius-md);
            background: white;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .item-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Text Note */
        .item-text {
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            min-height: 100px;
        }

        .item-text textarea {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-family: var(--font-primary);
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            color: #1d1d1f;
            border-radius: var(--radius-sm);
        }

        /* Color Swatch */
        .item-color {
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            border: 3px solid white;
        }

        /* Link Item */
        .item-link {
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            min-width: 200px;
        }

        .item-link a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
            word-break: break-all;
        }

        /* Drawing Canvas */
        .item-drawing {
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            background: white;
        }

        .item-drawing canvas {
            width: 100%;
            height: 100%;
            border-radius: var(--radius-md);
        }

        /* Emoji Item */
        .item-emoji {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            font-size: 48px;
            text-align: center;
        }

        /* === TRANSFORM HANDLES === */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: var(--radius-full);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
        }

        .canvas-item.selected .resize-handle {
            opacity: 1;
            pointer-events: all;
        }

        .resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

        .rotate-handle {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            background: var(--secondary);
            border: 2px solid white;
            border-radius: var(--radius-full);
            cursor: grab;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .canvas-item.selected .rotate-handle {
            opacity: 1;
            pointer-events: all;
        }

        .rotate-handle:active {
            cursor: grabbing;
        }

        /* === TOOLBAR === */
        #toolbar {
            position: fixed;
            bottom: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            z-index: 1000;
            animation: slideUp 0.5s var(--transition-bounce);
            border-radius: var(--radius-xl);
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        .tool-btn {
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .tool-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }

        .tool-btn:active {
            transform: translateY(-2px);
        }

        /* === SIDEBAR === */
        #sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            padding: var(--spacing-lg);
            transform: translateX(100%);
            transition: transform var(--transition-smooth);
            z-index: 2000;
            overflow-y: auto;
            border-radius: var(--radius-lg) 0 0 var(--radius-lg);
        }

        #sidebar.open {
            transform: translateX(0);
        }

        .sidebar-section {
            margin-bottom: var(--spacing-lg);
        }

        .sidebar-section h3 {
            font-size: 16px;
            margin-bottom: var(--spacing-md);
            color: white;
            font-weight: 600;
        }

        .board-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .board-item {
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .board-item:hover {
            background: white;
            transform: translateX(-4px);
        }

        .board-item.active {
            background: var(--primary);
            color: white;
        }

        .board-item-name {
            font-weight: 500;
        }

        .board-item-delete {
            color: var(--danger);
            cursor: pointer;
            padding: 4px 8px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            border-radius: var(--radius-full);
        }

        .board-item:hover .board-item-delete {
            opacity: 1;
        }

        .board-item.active .board-item-delete {
            color: white;
        }

        /* === MODAL === */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn var(--transition-fast);
        }

        .modal.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            max-width: 500px;
            width: 90%;
            padding: var(--spacing-xl);
            border-radius: var(--radius-lg);
            animation: scaleIn var(--transition-bounce);
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            color: #1d1d1f;
        }

        .modal-body {
            margin-bottom: var(--spacing-lg);
        }

        .modal-footer {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
        }

        .input-group {
            margin-bottom: var(--spacing-md);
        }

        .input-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
            font-size: 14px;
            color: #1d1d1f;
        }

        .input-group input,
        .input-group textarea,
        .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-md);
            font-family: var(--font-primary);
            font-size: 14px;
            transition: border var(--transition-fast);
            background: white;
        }

        .input-group input:focus,
        .input-group textarea:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .input-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .color-picker-group {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .color-picker-input {
            width: 60px !important;
            height: 60px;
            padding: 4px !important;
            cursor: pointer;
            border-radius: var(--radius-md);
        }

        /* === AI ASSISTANT === */
        #ai-panel {
            position: fixed;
            bottom: 100px;
            right: var(--spacing-lg);
            width: 350px;
            padding: var(--spacing-lg);
            transform: translateY(500px);
            transition: transform var(--transition-smooth);
            z-index: 1500;
            border-radius: var(--radius-lg);
        }

        #ai-panel.open {
            transform: translateY(0);
        }

        .ai-suggestion {
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .ai-suggestion:hover {
            background: white;
            transform: translateX(-4px);
        }

        .ai-suggestion-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #1d1d1f;
        }

        .ai-suggestion-desc {
            font-size: 12px;
            color: #86868b;
        }

        /* === SNAPPING GUIDES === */
        .guide-line {
            position: absolute;
            background: var(--primary);
            opacity: 0.6;
            pointer-events: none;
            z-index: 10000;
        }

        .guide-line.vertical {
            width: 1px;
            height: 100%;
        }

        .guide-line.horizontal {
            height: 1px;
            width: 100%;
        }

        /* === CONTEXT MENU === */
        #context-menu {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: none;
            z-index: 5000;
            min-width: 180px;
        }

        #context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 12px;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: rgba(0, 122, 255, 0.1);
        }

        .context-menu-divider {
            height: 1px;
            background: rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        /* === DRAWING TOOLS === */
        #drawing-tools {
            position: absolute;
            top: 10px;
            left: 10px;
            display: none;
            gap: var(--spacing-xs);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        #drawing-tools.show {
            display: flex;
        }

        .drawing-tool-btn {
            padding: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .drawing-tool-btn:hover {
            background: rgba(0, 122, 255, 0.1);
        }

        .drawing-tool-btn.active {
            background: var(--primary);
            color: white;
        }

        /* === EMOJI PICKER === */
        #emoji-picker {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-lg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: column;
            z-index: 1500;
            overflow: hidden;
        }

        #emoji-picker.show {
            display: flex;
        }

        .emoji-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .emoji-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-md);
            font-size: 14px;
        }

        .emoji-categories {
            display: flex;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .emoji-category-btn {
            padding: 6px 12px;
            border: none;
            background: transparent;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 16px;
            transition: background var(--transition-fast);
        }

        .emoji-category-btn.active {
            background: var(--primary);
            color: white;
        }

        .emoji-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--spacing-xs);
            padding: var(--spacing-sm);
            overflow-y: auto;
        }

        .emoji-item {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            padding: 6px;
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .emoji-item:hover {
            background: rgba(0, 122, 255, 0.1);
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            #header {
                flex-wrap: wrap;
            }

            .logo {
                font-size: 20px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 12px;
            }

            #toolbar {
                bottom: var(--spacing-md);
                flex-wrap: wrap;
                max-width: 90vw;
            }

            .tool-btn {
                padding: 10px 12px;
                font-size: 16px;
            }

            #sidebar {
                width: 100vw;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            }

            #ai-panel {
                width: calc(100vw - 2 * var(--spacing-lg));
                right: var(--spacing-md);
                bottom: 80px;
            }

            .modal-content {
                width: 95%;
                padding: var(--spacing-lg);
            }
            
            #emoji-picker {
                width: 90vw;
                height: 50vh;
                bottom: 120px;
            }
            
            .emoji-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        /* === LOADING SPINNER === */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: var(--radius-full);
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* === TOAST NOTIFICATIONS === */
        .toast {
            position: fixed;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            padding: var(--spacing-md) var(--spacing-lg);
            background: rgba(30, 30, 30, 0.95);
            color: white;
            border-radius: var(--radius-md);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform var(--transition-smooth);
            z-index: 6000;
            max-width: 300px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            background: var(--success);
        }

        .toast.error {
            background: var(--danger);
        }

        /* === ZOOM CONTROLS === */
        #zoom-controls {
            position: fixed;
            bottom: var(--spacing-lg);
            left: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--radius-full);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            transition: all var(--transition-fast);
        }

        .zoom-btn:hover {
            transform: scale(1.1);
        }

        .zoom-level {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        /* === AI BUTTON === */
        #ai-btn {
            position: relative;
            overflow: hidden;
        }
        
        #ai-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        #ai-btn:hover::before {
            left: 100%;
        }
        
        .ai-pulse {
            animation: aiPulse 2s infinite;
        }
        
        @keyframes aiPulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 122, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 122, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 122, 255, 0); }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header id="header">
            <div class="logo">‚ú® Gridora</div>
            <div class="header-controls">
                <button class="btn btn-secondary btn-icon" id="undo-btn" title="Undo">‚Ü∂</button>
                <button class="btn btn-secondary btn-icon" id="redo-btn" title="Redo">‚Ü∑</button>
                <button class="btn btn-secondary" id="boards-btn">üìã Boards</button>
                <button class="btn btn-secondary" id="settings-btn">‚öôÔ∏è</button>
                <button class="btn btn-primary ai-pulse" id="ai-btn">ü§ñ AI Assistant</button>
            </div>
        </header>

        <!-- Canvas Container -->
        <div id="canvas-container">
            <div id="canvas" class="dot-grid"></div>
        </div>

        <!-- Toolbar -->
        <div id="toolbar" class="glass">
            <button class="tool-btn" data-tool="image" title="Add Image">üñºÔ∏è</button>
            <button class="tool-btn" data-tool="text" title="Add Text Note">üìù</button>
            <button class="tool-btn" data-tool="color" title="Add Color Swatch">üé®</button>
            <button class="tool-btn" data-tool="link" title="Add Link">üîó</button>
            <button class="tool-btn" data-tool="drawing" title="Draw">‚úèÔ∏è</button>
            <button class="tool-btn" data-tool="emoji" title="Add Emoji">üòä</button>
        </div>

        <!-- Zoom Controls -->
        <div id="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <div class="zoom-level" id="zoom-level">100%</div>
            <button class="zoom-btn" id="zoom-out">‚àí</button>
            <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">‚äô</button>
        </div>

        <!-- Sidebar -->
        <div id="sidebar" class="glass-dark">
            <div class="sidebar-section">
                <h3>Moodboards</h3>
                <button class="btn btn-primary" id="new-board-btn" style="width: 100%; margin-bottom: 12px;">+ New Board</button>
                <div class="board-list" id="board-list"></div>
            </div>
        </div>

        <!-- AI Panel -->
        <div id="ai-panel" class="glass-dark">
            <h3 style="color: white; margin-bottom: 16px;">‚ú® AI Suggestions</h3>
            <div id="ai-suggestions"></div>
        </div>

        <!-- Emoji Picker -->
        <div id="emoji-picker" class="glass">
            <div class="emoji-header">
                <input type="text" class="emoji-search" placeholder="Search emojis...">
                <button class="btn btn-icon" id="close-emoji-picker">‚úï</button>
            </div>
            <div class="emoji-categories">
                <button class="emoji-category-btn active" data-category="all">All</button>
                <button class="emoji-category-btn" data-category="smileys">üòä</button>
                <button class="emoji-category-btn" data-category="animals">üê±</button>
                <button class="emoji-category-btn" data-category="food">üçé</button>
                <button class="emoji-category-btn" data-category="travel">üöó</button>
                <button class="emoji-category-btn" data-category="objects">üí°</button>
                <button class="emoji-category-btn" data-category="symbols">‚ù§Ô∏è</button>
            </div>
            <div class="emoji-grid" id="emoji-grid"></div>
        </div>

        <!-- Context Menu -->
        <div id="context-menu">
            <div class="context-menu-item" data-action="duplicate">üìã Duplicate</div>
            <div class="context-menu-item" data-action="bring-front">‚¨ÜÔ∏è Bring to Front</div>
            <div class="context-menu-item" data-action="send-back">‚¨áÔ∏è Send to Back</div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item" data-action="delete" style="color: var(--danger);">üóëÔ∏è Delete</div>
        </div>
    </div>

    <!-- Modals -->
    <div id="image-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Add Image</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Image URL or paste an image</label>
                    <input type="text" id="image-url-input" placeholder="https://example.com/image.jpg">
                </div>
                <div class="input-group">
                    <label>Or upload from device</label>
                    <input type="file" id="image-file-input" accept="image/*">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('image-modal')">Cancel</button>
                <button class="btn btn-primary" id="add-image-btn">Add Image</button>
            </div>
        </div>
    </div>

    <div id="text-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Add Text Note</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Your note</label>
                    <textarea id="text-content-input" placeholder="Type your note here..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('text-modal')">Cancel</button>
                <button class="btn btn-primary" id="add-text-btn">Add Note</button>
            </div>
        </div>
    </div>

    <div id="color-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Add Color Swatch</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Pick a color</label>
                    <div class="color-picker-group">
                        <input type="color" id="color-picker-input" class="color-picker-input" value="#667eea">
                        <input type="text" id="color-hex-input" placeholder="#667eea" value="#667eea">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('color-modal')">Cancel</button>
                <button class="btn btn-primary" id="add-color-btn">Add Swatch</button>
            </div>
        </div>
    </div>

    <div id="link-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Add Link</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>URL</label>
                    <input type="url" id="link-url-input" placeholder="https://example.com">
                </div>
                <div class="input-group">
                    <label>Display Text (optional)</label>
                    <input type="text" id="link-text-input" placeholder="My Link">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('link-modal')">Cancel</button>
                <button class="btn btn-primary" id="add-link-btn">Add Link</button>
            </div>
        </div>
    </div>

    <div id="board-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Create New Board</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Board Name</label>
                    <input type="text" id="board-name-input" placeholder="My Moodboard">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('board-modal')">Cancel</button>
                <button class="btn btn-primary" id="create-board-btn">Create</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content glass">
            <div class="modal-header">Settings</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Background Theme</label>
                    <select id="theme-select">
                        <option value="purple">Purple Gradient</option>
                        <option value="blue">Blue Ocean</option>
                        <option value="pink">Pink Sunset</option>
                        <option value="green">Forest Green</option>
                        <option value="orange">Orange Sunrise</option>
                        <option value="dark">Midnight</option>
                        <option value="pastel">Pastel Dreams</option>
                        <option value="neon">Neon Glow</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Canvas Background</label>
                    <select id="canvas-bg-select">
                        <option value="light">Light</option>
                        <option value="white">White</option>
                        <option value="dark">Dark</option>
                        <option value="grid">Dot Grid</option>
                        <option value="paper">Paper Texture</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="grid-toggle" checked> Show Dot Grid
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="snap-toggle" checked> Enable Snapping
                    </label>
                </div>
                <div class="input-group">
                    <button class="btn btn-secondary" style="width: 100%;" id="export-btn">üì§ Export JSON</button>
                </div>
                <div class="input-group">
                    <button class="btn btn-secondary" style="width: 100%;" id="import-btn">üì• Import JSON</button>
                    <input type="file" id="import-file-input" accept=".json" style="display: none;">
                </div>
                <div class="input-group">
                    <button class="btn btn-secondary" style="width: 100%;" id="clear-board-btn">üóëÔ∏è Clear Current Board</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('settings-modal')">Done</button>
            </div>
        </div>
    </div>

    <script>
        // === GLOBAL STATE ===
        const state = {
            boards: [],
            currentBoardId: null,
            items: [],
            selectedItem: null,
            history: [],
            historyIndex: -1,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            isPanning: false,
            isResizing: false,
            isRotating: false,
            dragStartX: 0,
            dragStartY: 0,
            settings: {
                theme: 'purple',
                canvasBg: 'light',
                showGrid: true,
                snapEnabled: true
            },
            nextItemId: 1,
            touchStartDistance: 0,
            touchStartZoom: 1
        };

        // === DATABASE (IndexedDB) ===
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('GridoraDB', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('boards')) {
                        db.createObjectStore('boards', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('items')) {
                        const itemStore = db.createObjectStore('items', { keyPath: 'id' });
                        itemStore.createIndex('boardId', 'boardId', { unique: false });
                    }
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'key' });
                    }
                };
            });
        }

        async function saveBoard(board) {
            const transaction = db.transaction(['boards'], 'readwrite');
            const store = transaction.objectStore('boards');
            await store.put(board);
        }

        async function loadBoards() {
            const transaction = db.transaction(['boards'], 'readonly');
            const store = transaction.objectStore('boards');
            const request = store.getAll();
            
            return new Promise((resolve) => {
                request.onsuccess = () => resolve(request.result);
            });
        }

        async function deleteBoard(boardId) {
            const transaction = db.transaction(['boards', 'items'], 'readwrite');
            const boardStore = transaction.objectStore('boards');
            const itemStore = transaction.objectStore('items');
            
            await boardStore.delete(boardId);
            
            const index = itemStore.index('boardId');
            const items = await index.getAll(boardId);
            
            return new Promise((resolve) => {
                items.onsuccess = () => {
                    const itemsToDelete = items.result;
                    itemsToDelete.forEach(item => itemStore.delete(item.id));
                    resolve();
                };
            });
        }

        async function saveItem(item) {
            const transaction = db.transaction(['items'], 'readwrite');
            const store = transaction.objectStore('items');
            await store.put(item);
        }

        async function loadItems(boardId) {
            const transaction = db.transaction(['items'], 'readonly');
            const store = transaction.objectStore('items');
            const index = store.index('boardId');
            const request = index.getAll(boardId);
            
            return new Promise((resolve) => {
                request.onsuccess = () => resolve(request.result);
            });
        }

        async function deleteItem(itemId) {
            const transaction = db.transaction(['items'], 'readwrite');
            const store = transaction.objectStore('items');
            await store.delete(itemId);
        }

        async function saveSettings() {
            const transaction = db.transaction(['settings'], 'readwrite');
            const store = transaction.objectStore('settings');
            await store.put({ key: 'settings', value: state.settings });
        }

        async function loadSettings() {
            const transaction = db.transaction(['settings'], 'readonly');
            const store = transaction.objectStore('settings');
            const request = store.get('settings');
            
            return new Promise((resolve) => {
                request.onsuccess = () => {
                    if (request.result) {
                        resolve(request.result.value);
                    } else {
                        resolve(null);
                    }
                };
            });
        }

        // === UTILITIES ===
        function generateId() {
            return 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 10);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function openModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // === BOARD MANAGEMENT ===
        async function createBoard(name) {
            const board = {
                id: generateId(),
                name: name || 'Untitled Board',
                createdAt: Date.now(),
                updatedAt: Date.now()
            };
            
            state.boards.push(board);
            await saveBoard(board);
            renderBoardList();
            switchBoard(board.id);
            showToast('Board created', 'success');
        }

        async function switchBoard(boardId) {
            if (state.currentBoardId === boardId) return;
            
            // Save current board state
            if (state.currentBoardId) {
                await autoSave();
            }
            
            state.currentBoardId = boardId;
            state.items = await loadItems(boardId);
            state.history = [];
            state.historyIndex = -1;
            
            renderCanvas();
            renderBoardList();
            
            const board = state.boards.find(b => b.id === boardId);
            showToast(`Switched to ${board.name}`, 'success');
        }

        async function removeboard(boardId) {
            if (state.boards.length === 1) {
                showToast('Cannot delete the last board', 'error');
                return;
            }
            
            const index = state.boards.findIndex(b => b.id === boardId);
            if (index === -1) return;
            
            await deleteBoard(boardId);
            state.boards.splice(index, 1);
            
            if (state.currentBoardId === boardId) {
                await switchBoard(state.boards[0].id);
            }
            
            renderBoardList();
            showToast('Board deleted', 'success');
        }

        function renderBoardList() {
            const boardList = document.getElementById('board-list');
            boardList.innerHTML = '';
            
            state.boards.forEach(board => {
                const boardItem = document.createElement('div');
                boardItem.className = 'board-item';
                if (board.id === state.currentBoardId) {
                    boardItem.classList.add('active');
                }
                
                boardItem.innerHTML = `
                    <span class="board-item-name">${board.name}</span>
                    <span class="board-item-delete" data-board-id="${board.id}">√ó</span>
                `;
                
                boardItem.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('board-item-delete')) {
                        switchBoard(board.id);
                        document.getElementById('sidebar').classList.remove('open');
                    }
                });
                
                const deleteBtn = boardItem.querySelector('.board-item-delete');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`Delete board "${board.name}"?`)) {
                        removeboard(board.id);
                    }
                });
                
                boardList.appendChild(boardItem);
            });
        }

        // === CANVAS ITEMS ===
        async function addItem(type, data) {
            const item = {
                id: generateId(),
                type: type,
                boardId: state.currentBoardId,
                data: data,
                x: window.innerWidth / 2 - 100,
                y: window.innerHeight / 2 - 100,
                width: 200,
                height: 200,
                rotation: 0,
                zIndex: state.items.length
            };
            
            if (type === 'text') {
                item.height = 150;
            } else if (type === 'color') {
                item.width = 150;
                item.height = 150;
            } else if (type === 'link') {
                item.height = 80;
            } else if (type === 'emoji') {
                item.width = 120;
                item.height = 120;
            }
            
            state.items.push(item);
            await saveItem(item);
            renderCanvas();
            addToHistory();
            showToast('Item added', 'success');
        }

        function renderCanvas() {
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            
            // Sort by z-index
            const sortedItems = [...state.items].sort((a, b) => a.zIndex - b.zIndex);
            
            sortedItems.forEach(item => {
                const element = createItemElement(item);
                canvas.appendChild(element);
            });
        }

        function createItemElement(item) {
            const div = document.createElement('div');
            div.className = 'canvas-item';
            div.dataset.itemId = item.id;
            div.style.left = item.x + 'px';
            div.style.top = item.y + 'px';
            div.style.width = item.width + 'px';
            div.style.height = item.height + 'px';
            div.style.transform = `rotate(${item.rotation}deg)`;
            div.style.zIndex = item.zIndex;
            
            // Create content based on type
            switch (item.type) {
                case 'image':
                    div.classList.add('item-image');
                    const img = document.createElement('img');
                    img.src = item.data.url;
                    img.alt = 'Moodboard image';
                    div.appendChild(img);
                    break;
                    
                case 'text':
                    div.classList.add('item-text');
                    const textarea = document.createElement('textarea');
                    textarea.value = item.data.text;
                    textarea.addEventListener('input', (e) => {
                        item.data.text = e.target.value;
                        autoSave();
                    });
                    div.appendChild(textarea);
                    break;
                    
                case 'color':
                    div.classList.add('item-color');
                    div.style.backgroundColor = item.data.color;
                    break;
                    
                case 'link':
                    div.classList.add('item-link');
                    const link = document.createElement('a');
                    link.href = item.data.url;
                    link.target = '_blank';
                    link.textContent = item.data.text || item.data.url;
                    div.appendChild(link);
                    break;
                    
                case 'drawing':
                    div.classList.add('item-drawing');
                    const canvas = document.createElement('canvas');
                    canvas.width = item.width;
                    canvas.height = item.height;
                    const ctx = canvas.getContext('2d');
                    
                    if (item.data.imageData) {
                        const img = new Image();
                        img.onload = () => ctx.drawImage(img, 0, 0);
                        img.src = item.data.imageData;
                    }
                    
                    div.appendChild(canvas);
                    break;
                    
                case 'emoji':
                    div.classList.add('item-emoji');
                    div.textContent = item.data.emoji;
                    break;
            }
            
            // Add transform handles
            if (item.type !== 'text') {
                addTransformHandles(div);
            }
            
            // Add event listeners
            div.addEventListener('mousedown', handleItemMouseDown);
            div.addEventListener('touchstart', handleItemTouchStart);
            div.addEventListener('contextmenu', handleContextMenu);
            
            return div;
        }

        function addTransformHandles(element) {
            const handles = ['nw', 'ne', 'sw', 'se'];
            handles.forEach(position => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${position}`;
                handle.dataset.handle = position;
                element.appendChild(handle);
            });
            
            const rotateHandle = document.createElement('div');
            rotateHandle.className = 'rotate-handle';
            rotateHandle.textContent = '‚Üª';
            element.appendChild(rotateHandle);
        }

        // === ITEM INTERACTIONS ===
        function selectItem(itemId) {
            // Deselect previous
            if (state.selectedItem) {
                const prevElement = document.querySelector(`[data-item-id="${state.selectedItem}"]`);
                if (prevElement) prevElement.classList.remove('selected');
            }
            
            state.selectedItem = itemId;
            
            if (itemId) {
                const element = document.querySelector(`[data-item-id="${itemId}"]`);
                if (element) element.classList.add('selected');
            }
        }

        function handleItemMouseDown(e) {
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'A') return;
            
            e.stopPropagation();
            const itemId = e.currentTarget.dataset.itemId;
            selectItem(itemId);
            
            if (e.target.classList.contains('resize-handle')) {
                startResize(e, itemId, e.target.dataset.handle);
            } else if (e.target.classList.contains('rotate-handle')) {
                startRotate(e, itemId);
            } else {
                startDrag(e, itemId);
            }
        }

        function handleItemTouchStart(e) {
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'A') return;
            
            e.stopPropagation();
            const itemId = e.currentTarget.dataset.itemId;
            
            // Long press to select
            const longPressTimer = setTimeout(() => {
                selectItem(itemId);
            }, 500);
            
            e.currentTarget.dataset.longPressTimer = longPressTimer;
            
            const touch = e.touches[0];
            
            if (e.target.classList.contains('resize-handle')) {
                clearTimeout(longPressTimer);
                startResize({ clientX: touch.clientX, clientY: touch.clientY }, itemId, e.target.dataset.handle);
            } else if (e.target.classList.contains('rotate-handle')) {
                clearTimeout(longPressTimer);
                startRotate({ clientX: touch.clientX, clientY: touch.clientY }, itemId);
            } else {
                startDrag({ clientX: touch.clientX, clientY: touch.clientY }, itemId);
            }
        }

        function startDrag(e, itemId) {
            state.isDragging = true;
            state.dragStartX = e.clientX;
            state.dragStartY = e.clientY;
            
            const item = state.items.find(i => i.id === itemId);
            state.dragStartItemX = item.x;
            state.dragStartItemY = item.y;
            
            const element = document.querySelector(`[data-item-id="${itemId}"]`);
            element.classList.add('dragging');
        }

        function startResize(e, itemId, handle) {
            state.isResizing = true;
            state.resizeHandle = handle;
            state.dragStartX = e.clientX;
            state.dragStartY = e.clientY;
            
            const item = state.items.find(i => i.id === itemId);
            state.dragStartItemX = item.x;
            state.dragStartItemY = item.y;
            state.dragStartItemWidth = item.width;
            state.dragStartItemHeight = item.height;
        }

        function startRotate(e, itemId) {
            state.isRotating = true;
            
            const item = state.items.find(i => i.id === itemId);
            const element = document.querySelector(`[data-item-id="${itemId}"]`);
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            state.rotateCenterX = centerX;
            state.rotateCenterY = centerY;
            state.rotateStartAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
            state.rotateStartRotation = item.rotation;
        }

        // === MOUSE & TOUCH EVENTS ===
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('touchmove', handleTouchMove);
        document.addEventListener('touchend', handleTouchEnd);

        function handleMouseMove(e) {
            if (!state.selectedItem) return;
            
            const item = state.items.find(i => i.id === state.selectedItem);
            if (!item) return;
            
            if (state.isDragging) {
                const dx = e.clientX - state.dragStartX;
                const dy = e.clientY - state.dragStartY;
                
                item.x = state.dragStartItemX + dx / state.zoom;
                item.y = state.dragStartItemY + dy / state.zoom;
                
                // Snapping
                if (state.settings.snapEnabled) {
                    item.x = Math.round(item.x / 10) * 10;
                    item.y = Math.round(item.y / 10) * 10;
                }
                
                updateItemElement(item);
            } else if (state.isResizing) {
                const dx = e.clientX - state.dragStartX;
                const dy = e.clientY - state.dragStartY;
                
                const handle = state.resizeHandle;
                
                if (handle.includes('e')) {
                    item.width = Math.max(50, state.dragStartItemWidth + dx / state.zoom);
                }
                if (handle.includes('w')) {
                    const newWidth = Math.max(50, state.dragStartItemWidth - dx / state.zoom);
                    item.x = state.dragStartItemX + (state.dragStartItemWidth - newWidth);
                    item.width = newWidth;
                }
                if (handle.includes('s')) {
                    item.height = Math.max(50, state.dragStartItemHeight + dy / state.zoom);
                }
                if (handle.includes('n')) {
                    const newHeight = Math.max(50, state.dragStartItemHeight - dy / state.zoom);
                    item.y = state.dragStartItemY + (state.dragStartItemHeight - newHeight);
                    item.height = newHeight;
                }
                
                updateItemElement(item);
            } else if (state.isRotating) {
                const angle = Math.atan2(e.clientY - state.rotateCenterY, e.clientX - state.rotateCenterX) * 180 / Math.PI;
                item.rotation = state.rotateStartRotation + (angle - state.rotateStartAngle);
                
                updateItemElement(item);
            }
        }

        function handleMouseUp(e) {
            if (state.isDragging || state.isResizing || state.isRotating) {
                autoSave();
                addToHistory();
            }
            
            state.isDragging = false;
            state.isResizing = false;
            state.isRotating = false;
            state.isPanning = false;
            
            document.querySelectorAll('.canvas-item.dragging').forEach(el => {
                el.classList.remove('dragging');
            });
            
            document.getElementById('canvas').classList.remove('grabbing');
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                // Pinch to zoom
                handlePinchZoom(e);
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function handleTouchEnd(e) {
            const element = e.target.closest('.canvas-item');
            if (element && element.dataset.longPressTimer) {
                clearTimeout(element.dataset.longPressTimer);
            }
            
            handleMouseUp(e);
        }

        function handlePinchZoom(e) {
            e.preventDefault();
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            const distance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            if (state.touchStartDistance === 0) {
                state.touchStartDistance = distance;
                state.touchStartZoom = state.zoom;
            } else {
                const scale = distance / state.touchStartDistance;
                setZoom(state.touchStartZoom * scale);
            }
        }

        function updateItemElement(item) {
            const element = document.querySelector(`[data-item-id="${item.id}"]`);
            if (!element) return;
            
            element.style.left = item.x + 'px';
            element.style.top = item.y + 'px';
            element.style.width = item.width + 'px';
            element.style.height = item.height + 'px';
            element.style.transform = `rotate(${item.rotation}deg)`;
            
            // Update canvas size for drawings
            if (item.type === 'drawing') {
                const canvas = element.querySelector('canvas');
                if (canvas) {
                    canvas.width = item.width;
                    canvas.height = item.height;
                }
            }
        }

        // === CONTEXT MENU ===
        function handleContextMenu(e) {
            e.preventDefault();
            const menu = document.getElementById('context-menu');
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.classList.add('show');
        }

        document.addEventListener('click', () => {
            document.getElementById('context-menu').classList.remove('show');
        });

        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', async (e) => {
                const action = e.currentTarget.dataset.action;
                const itemId = state.selectedItem;
                
                if (!itemId) return;
                
                switch (action) {
                    case 'duplicate':
                        await duplicateItem(itemId);
                        break;
                    case 'bring-front':
                        bringToFront(itemId);
                        break;
                    case 'send-back':
                        sendToBack(itemId);
                        break;
                    case 'delete':
                        await removeItem(itemId);
                        break;
                }
            });
        });

        async function duplicateItem(itemId) {
            const original = state.items.find(i => i.id === itemId);
            if (!original) return;
            
            const duplicate = {
                ...JSON.parse(JSON.stringify(original)),
                id: generateId(),
                x: original.x + 20,
                y: original.y + 20,
                zIndex: state.items.length
            };
            
            state.items.push(duplicate);
            await saveItem(duplicate);
            renderCanvas();
            addToHistory();
            showToast('Item duplicated', 'success');
        }

        function bringToFront(itemId) {
            const item = state.items.find(i => i.id === itemId);
            if (!item) return;
            
            const maxZ = Math.max(...state.items.map(i => i.zIndex));
            item.zIndex = maxZ + 1;
            
            renderCanvas();
            autoSave();
            addToHistory();
        }

        function sendToBack(itemId) {
            const item = state.items.find(i => i.id === itemId);
            if (!item) return;
            
            const minZ = Math.min(...state.items.map(i => i.zIndex));
            item.zIndex = minZ - 1;
            
            renderCanvas();
            autoSave();
            addToHistory();
        }

        async function removeItem(itemId) {
            const index = state.items.findIndex(i => i.id === itemId);
            if (index === -1) return;
            
            await deleteItem(itemId);
            state.items.splice(index, 1);
            
            if (state.selectedItem === itemId) {
                state.selectedItem = null;
            }
            
            renderCanvas();
            addToHistory();
            showToast('Item deleted', 'success');
        }

        // === ZOOM & PAN ===
        function setZoom(zoom) {
            state.zoom = Math.max(0.25, Math.min(3, zoom));
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${state.zoom})`;
            
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }

        document.getElementById('zoom-in').addEventListener('click', () => {
            setZoom(state.zoom + 0.25);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            setZoom(state.zoom - 0.25);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            setZoom(1);
        });

        // Canvas panning
        const canvas = document.getElementById('canvas');
        canvas.addEventListener('mousedown', (e) => {
            if (e.target === canvas) {
                state.isPanning = true;
                state.dragStartX = e.clientX;
                state.dragStartY = e.clientY;
                canvas.classList.add('grabbing');
                selectItem(null);
            }
        });

        // === UNDO/REDO ===
        function addToHistory() {
            const snapshot = JSON.parse(JSON.stringify(state.items));
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(snapshot);
            state.historyIndex++;
            
            // Limit history to 50 states
            if (state.history.length > 50) {
                state.history.shift();
                state.historyIndex--;
            }
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                state.items = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                renderCanvas();
                autoSave();
                showToast('Undo', 'info');
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                state.items = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                renderCanvas();
                autoSave();
                showToast('Redo', 'info');
            }
        }

        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (state.selectedItem) {
                    e.preventDefault();
                    removeItem(state.selectedItem);
                }
            }
        });

        // === AUTO-SAVE ===
        let autoSaveTimer;
        async function autoSave() {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(async () => {
                if (!state.currentBoardId) return;
                
                for (const item of state.items) {
                    await saveItem(item);
                }
                
                // Update board timestamp
                const board = state.boards.find(b => b.id === state.currentBoardId);
                if (board) {
                    board.updatedAt = Date.now();
                    await saveBoard(board);
                }
            }, 1000);
        }

        // === TOOLBAR ===
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tool = btn.dataset.tool;
                
                switch (tool) {
                    case 'image':
                        openModal('image-modal');
                        break;
                    case 'text':
                        openModal('text-modal');
                        break;
                    case 'color':
                        openModal('color-modal');
                        break;
                    case 'link':
                        openModal('link-modal');
                        break;
                    case 'drawing':
                        createDrawing();
                        break;
                    case 'emoji':
                        openEmojiPicker();
                        break;
                }
            });
        });

        // === ADD ITEMS ===
        document.getElementById('add-image-btn').addEventListener('click', async () => {
            const urlInput = document.getElementById('image-url-input');
            const fileInput = document.getElementById('image-file-input');
            
            let imageUrl = urlInput.value;
            
            if (fileInput.files[0]) {
                imageUrl = await fileToDataURL(fileInput.files[0]);
            }
            
            if (imageUrl) {
                await addItem('image', { url: imageUrl });
                urlInput.value = '';
                fileInput.value = '';
                closeModal('image-modal');
            } else {
                showToast('Please provide an image URL or file', 'error');
            }
        });

        document.getElementById('add-text-btn').addEventListener('click', async () => {
            const text = document.getElementById('text-content-input').value;
            
            await addItem('text', { text: text || 'New note' });
            document.getElementById('text-content-input').value = '';
            closeModal('text-modal');
        });

        document.getElementById('add-color-btn').addEventListener('click', async () => {
            const color = document.getElementById('color-picker-input').value;
            
            await addItem('color', { color });
            closeModal('color-modal');
        });

        document.getElementById('add-link-btn').addEventListener('click', async () => {
            const url = document.getElementById('link-url-input').value;
            const text = document.getElementById('link-text-input').value;
            
            if (url) {
                await addItem('link', { url, text: text || url });
                document.getElementById('link-url-input').value = '';
                document.getElementById('link-text-input').value = '';
                closeModal('link-modal');
            } else {
                showToast('Please provide a URL', 'error');
            }
        });

        // Color picker sync
        document.getElementById('color-picker-input').addEventListener('input', (e) => {
            document.getElementById('color-hex-input').value = e.target.value;
        });

        document.getElementById('color-hex-input').addEventListener('input', (e) => {
            const color = e.target.value;
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                document.getElementById('color-picker-input').value = color;
            }
        });

        // === EMOJI PICKER ===
        function openEmojiPicker() {
            document.getElementById('emoji-picker').classList.add('show');
            populateEmojiGrid();
        }

        function closeEmojiPicker() {
            document.getElementById('emoji-picker').classList.remove('show');
        }

        document.getElementById('close-emoji-picker').addEventListener('click', closeEmojiPicker);

        // Emoji categories
        const emojiCategories = {
            all: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà', 'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ', 'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ'],
            smileys: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà', 'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ', 'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ'],
            animals: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ', 'üôà', 'üôâ', 'üôä', 'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó', 'üï∑', 'üï∏', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò', 'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêè', 'üêë', 'ü¶ô', 'üêê', 'ü¶å', 'üêï', 'üê©', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üêà', 'üêì', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶©', 'üêá', 'ü¶ù', 'ü¶®', 'ü¶°', 'ü¶¶', 'ü¶•', 'üêÅ', 'üêÄ', 'üêø', 'ü¶î'],
            food: ['üçè', 'üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê', 'ü•Ø', 'üçû', 'ü•ñ', 'ü•®', 'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó', 'üçñ', 'ü¶¥', 'üå≠', 'üçî', 'üçü', 'üçï', 'ü´ì', 'ü•™', 'ü•ô', 'üßÜ', 'üåÆ', 'üåØ', 'ü´î', 'ü•ó', 'ü•ò', 'ü´ï', 'ü•´', 'üçù', 'üçú', 'üç≤', 'üçõ', 'üç£', 'üç±', 'ü•ü', 'ü¶™', 'üç§', 'üçô', 'üçö', 'üçò', 'üç•', 'ü•†', 'ü•Æ', 'üç¢', 'üç°', 'üçß', 'üç®', 'üç¶', 'ü•ß', 'üßÅ', 'üç∞', 'üéÇ', 'üçÆ', 'üç≠', 'üç¨', 'üç´', 'üçø', 'üç©', 'üç™', 'üå∞', 'ü•ú', 'üçØ', 'ü•õ', 'üçº', 'ü´ñ', '‚òï', 'üçµ', 'üßÉ', 'ü•§', 'üßã', 'üç∂', 'üç∫', 'üçª', 'ü•Ç', 'üç∑', 'ü•É', 'üç∏', 'üçπ', 'üßâ', 'üçæ', 'üßä', 'ü•Ñ', 'üç¥', 'üçΩ', 'ü•£', 'ü•°', 'ü•¢'],
            travel: ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèé', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'ü¶Ø', 'ü¶Ω', 'ü¶º', 'üõ¥', 'üö≤', 'üõµ', 'üèç', 'üõ∫', 'üö®', 'üöî', 'üöç', 'üöò', 'üöñ', 'üö°', 'üö†', 'üöü', 'üöÉ', 'üöã', 'üöû', 'üöù', 'üöÑ', 'üöÖ', 'üöà', 'üöÇ', 'üöÜ', 'üöá', 'üöä', 'üöâ', '‚úàÔ∏è', 'üõ´', 'üõ¨', 'üõ©', 'üí∫', 'üõ∞', 'üöÄ', 'üõ∏', 'üöÅ', 'üõ∂', '‚õµ', 'üö§', 'üõ•', 'üõ≥', '‚õ¥', 'üö¢', '‚öì', '‚õΩ', 'üöß', 'üö¶', 'üö•', 'üöè', 'üó∫', 'üóø', 'üóΩ', 'üóº', 'üè∞', 'üèØ', 'üèü', 'üé°', 'üé¢', 'üé†', '‚õ≤', '‚õ±', 'üèñ', 'üèù', 'üèú', 'üåã', '‚õ∞', 'üèî', 'üóª', 'üèï', 'üè†', 'üè°', 'üèò', 'üèö', 'üèó', 'üè≠', 'üè¢', 'üè¨', 'üè£', 'üè§', 'üè•', 'üè¶', 'üè®', 'üè™', 'üè´', 'üè©', 'üíí', 'üèõ', '‚õ™', 'üïå', 'üïç', 'üõï', 'üïã', '‚õ©', 'üóæ', 'üéë', 'üèû', 'üåÖ', 'üåÑ', 'üå†', 'üéá', 'üéÜ', 'üåá', 'üåÜ', 'üèô', 'üåÉ', 'üåå', 'üåâ', 'üåÅ'],
            objects: ['‚åö', 'üì±', 'üì≤', 'üíª', '‚å®Ô∏è', 'üñ•', 'üñ®', 'üñ±', 'üñ≤', 'üïπ', 'üóú', 'üíΩ', 'üíæ', 'üíø', 'üìÄ', 'üìº', 'üì∑', 'üì∏', 'üìπ', 'üé•', 'üìΩ', 'üéû', 'üìû', '‚òéÔ∏è', 'üìü', 'üì†', 'üì∫', 'üìª', 'üéô', 'üéö', 'üéõ', 'üß≠', '‚è±', '‚è≤', '‚è∞', 'üï∞', '‚åõ', '‚è≥', 'üì°', 'üîã', 'üîå', 'üí°', 'üî¶', 'üïØ', 'ü™î', 'üßØ', 'üõ¢', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'üí∞', 'üí≥', 'üíé', '‚öñÔ∏è', 'üß∞', 'üîß', 'üî®', '‚öí', 'üõ†', '‚õè', 'üî©', '‚öôÔ∏è', 'üß±', '‚õì', 'üß≤', 'üî´', 'üí£', 'üß®', 'ü™ì', 'üî™', 'üó°', '‚öîÔ∏è', 'üõ°', 'üö¨', '‚ö∞Ô∏è', '‚ö±Ô∏è', 'üè∫', 'üîÆ', 'üìø', 'üßø', 'üíà', '‚öóÔ∏è', 'üî≠', 'üî¨', 'üï≥', 'ü©π', 'ü©∫', 'üíä', 'üíâ', 'ü©∏', 'üß¨', 'ü¶†', 'üß´', 'üß™', 'üå°', 'üßπ', 'üß∫', 'üßª', 'üöΩ', 'üö∞', 'üöø', 'üõÅ', 'üõÄ', 'üßº', 'ü™í', 'üßΩ', 'üß¥', 'üõé', 'üîë', 'üóù', 'üö™', 'ü™ë', 'üõã', 'üõè', 'üõå', 'üß∏', 'üñº', 'üõç', 'üõí', 'üéÅ', 'üéà', 'üéè', 'üéÄ', 'üéä', 'üéâ', 'üéé', 'üèÆ', 'üéê', '‚úâÔ∏è', 'üì©', 'üì®', 'üìß', 'üíå', 'üì•', 'üì§', 'üì¶', 'üè∑', 'üì™', 'üì´', 'üì¨', 'üì≠', 'üìÆ', 'üìØ', 'üìú', 'üìÉ', 'üìÑ', 'üìë', 'üßæ', 'üìä', 'üìà', 'üìâ', 'üóí', 'üóì', 'üìÜ', 'üìÖ', 'üóë', 'üìá', 'üóÉ', 'üó≥', 'üóÑ', 'üìã', 'üìÅ', 'üìÇ', 'üóÇ', 'üóû', 'üì∞', 'üìì', 'üìî', 'üìí', 'üìï', 'üìó', 'üìò', 'üìô', 'üìö', 'üìñ', 'üîñ', 'üß∑', 'üîó', 'üìé', 'üñá', 'üìê', 'üìè', 'üßÆ', 'üìå', 'üìç', '‚úÇÔ∏è', 'üñä', 'üñã', '‚úíÔ∏è', 'üñå', 'üñç', 'üìù', '‚úèÔ∏è', 'üîç', 'üîé', 'üîè', 'üîê', 'üîí', 'üîì'],
            symbols: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâ', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ', '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥', 'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üÜö', 'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤', 'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï', 'üõë', '‚õî', 'üìõ', 'üö´', 'üíØ', 'üí¢', '‚ô®Ô∏è', 'üö∑', 'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠', '‚ùó', '‚ùï', '‚ùì', '‚ùî', '‚ÄºÔ∏è', '‚ÅâÔ∏è', 'üîÖ', 'üîÜ', '„ÄΩÔ∏è', '‚ö†Ô∏è', 'üö∏', 'üî±', '‚öúÔ∏è', 'üî∞', '‚ôªÔ∏è', '‚úÖ', 'üàØ', 'üíπ', '‚ùáÔ∏è', '‚ú≥Ô∏è', '‚ùé', 'üåê', 'üí†', '‚ìÇÔ∏è', 'üåÄ', 'üí§', 'üèß', 'üöæ', '‚ôø', 'üÖøÔ∏è', 'üà≥', 'üàÇÔ∏è', 'üõÇ', 'üõÉ', 'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöº', 'üöª', 'üöÆ', 'üé¶', 'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üÜñ', 'üÜó', 'üÜô', 'üÜí', 'üÜï', 'üÜì', '0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü', 'üî¢', '#Ô∏è‚É£', '*Ô∏è‚É£', '‚èèÔ∏è', '‚ñ∂Ô∏è', '‚è∏', '‚èØ', '‚èπ', '‚è∫', '‚è≠', '‚èÆ', '‚è©', '‚è™', '‚è´', '‚è¨', '‚óÄÔ∏è', 'üîº', 'üîΩ', '‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚ÜóÔ∏è', '‚ÜòÔ∏è', '‚ÜôÔ∏è', '‚ÜñÔ∏è', '‚ÜïÔ∏è', '‚ÜîÔ∏è', '‚Ü™Ô∏è', '‚Ü©Ô∏è', '‚§¥Ô∏è', '‚§µÔ∏è', 'üîÄ', 'üîÅ', 'üîÇ', 'üîÑ', 'üîÉ', 'üéµ', 'üé∂', '‚ûï', '‚ûñ', '‚ûó', '‚úñÔ∏è', '‚ôæ', 'üí≤', 'üí±', '‚Ñ¢Ô∏è', '¬©Ô∏è', '¬ÆÔ∏è', '„Ä∞Ô∏è', '‚û∞', '‚ûø', 'üîö', 'üîô', 'üîõ', 'üîù', 'üîú', '‚úîÔ∏è', '‚òëÔ∏è', 'üîò', 'üî¥', 'üü†', 'üü°', 'üü¢', 'üîµ', 'üü£', '‚ö´', '‚ö™', 'üü§', 'üî∫', 'üîª', 'üî∏', 'üîπ', 'üî∂', 'üî∑', 'üî≥', 'üî≤', '‚ñ™Ô∏è', '‚ñ´Ô∏è', '‚óæ', '‚óΩ', '‚óºÔ∏è', '‚óªÔ∏è', 'üü•', 'üüß', 'üü®', 'üü©', 'üü¶', 'üü™', '‚¨õ', '‚¨ú', 'üü´', 'üîà', 'üîá', 'üîâ', 'üîä', 'üîî', 'üîï', 'üì£', 'üì¢', 'üëÅ‚Äçüó®', 'üí¨', 'üí≠', 'üóØ', '‚ô†Ô∏è', '‚ô£Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', 'üÉè', 'üé¥', 'üÄÑ', 'üïê', 'üïë', 'üïí', 'üïì', 'üïî', 'üïï', 'üïñ', 'üïó', 'üïò', 'üïô', 'üïö', 'üïõ', 'üïú', 'üïù', 'üïû', 'üïü', 'üï†', 'üï°', 'üï¢', 'üï£', 'üï§', 'üï•', 'üï¶', 'üïß']
        };

        function populateEmojiGrid(category = 'all') {
            const emojiGrid = document.getElementById('emoji-grid');
            emojiGrid.innerHTML = '';
            
            const emojis = emojiCategories[category] || emojiCategories.all;
            
            emojis.forEach(emoji => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'emoji-item';
                emojiItem.textContent = emoji;
                emojiItem.addEventListener('click', () => {
                    addItem('emoji', { emoji });
                    closeEmojiPicker();
                });
                emojiGrid.appendChild(emojiItem);
            });
        }

        // Emoji category buttons
        document.querySelectorAll('.emoji-category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.emoji-category-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                populateEmojiGrid(btn.dataset.category);
            });
        });

        // Emoji search
        document.querySelector('.emoji-search').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const emojiGrid = document.getElementById('emoji-grid');
            emojiGrid.innerHTML = '';
            
            // Search through all emojis
            const allEmojis = emojiCategories.all;
            const filteredEmojis = allEmojis.filter(emoji => {
                // This is a simple search - in a real app you'd want to use an emoji library with names
                return emoji.includes(searchTerm);
            });
            
            filteredEmojis.forEach(emoji => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'emoji-item';
                emojiItem.textContent = emoji;
                emojiItem.addEventListener('click', () => {
                    addItem('emoji', { emoji });
                    closeEmojiPicker();
                });
                emojiGrid.appendChild(emojiItem);
            });
        });

        // === DRAWING ===
        async function createDrawing() {
            const item = {
                id: generateId(),
                type: 'drawing',
                boardId: state.currentBoardId,
                data: { imageData: null },
                x: window.innerWidth / 2 - 200,
                y: window.innerHeight / 2 - 200,
                width: 400,
                height: 300,
                rotation: 0,
                zIndex: state.items.length
            };
            
            state.items.push(item);
            await saveItem(item);
            renderCanvas();
            addToHistory();
            
            selectItem(item.id);
            initDrawingCanvas(item.id);
            showToast('Drawing canvas created - click to draw', 'success');
        }

        function initDrawingCanvas(itemId) {
            const element = document.querySelector(`[data-item-id="${itemId}"]`);
            const canvas = element.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                lastX = x;
                lastY = y;
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                const item = state.items.find(i => i.id === itemId);
                item.data.imageData = canvas.toDataURL();
                autoSave();
            });
            
            canvas.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                lastX = touch.clientX - rect.left;
                lastY = touch.clientY - rect.top;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                lastX = x;
                lastY = y;
            });
            
            canvas.addEventListener('touchend', () => {
                isDrawing = false;
                const item = state.items.find(i => i.id === itemId);
                item.data.imageData = canvas.toDataURL();
                autoSave();
            });
        }

        function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // === SETTINGS ===
        document.getElementById('settings-btn').addEventListener('click', () => {
            openModal('settings-modal');
        });

        document.getElementById('theme-select').addEventListener('change', (e) => {
            state.settings.theme = e.target.value;
            applyTheme();
            saveSettings();
        });

        document.getElementById('canvas-bg-select').addEventListener('change', (e) => {
            state.settings.canvasBg = e.target.value;
            applyCanvasBackground();
            saveSettings();
        });

        document.getElementById('grid-toggle').addEventListener('change', (e) => {
            state.settings.showGrid = e.target.checked;
            document.getElementById('canvas').classList.toggle('dot-grid', e.target.checked);
            saveSettings();
        });

        document.getElementById('snap-toggle').addEventListener('change', (e) => {
            state.settings.snapEnabled = e.target.checked;
            saveSettings();
        });

        function applyTheme() {
            const themes = {
                purple: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                blue: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                pink: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                green: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                orange: 'linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%)',
                dark: 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)',
                pastel: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                neon: 'linear-gradient(135deg, #00dbde 0%, #fc00ff 100%)'
            };
            
            document.body.style.background = themes[state.settings.theme] || themes.purple;
        }

        function applyCanvasBackground() {
            const backgrounds = {
                light: '#f5f5f7',
                white: '#ffffff',
                dark: '#2c2c2e',
                grid: 'repeating-linear-gradient(0deg, transparent, transparent 19px, #e0e0e0 20px), repeating-linear-gradient(90deg, transparent, transparent 19px, #e0e0e0 20px)',
                paper: 'linear-gradient(to bottom, #f5f5f7, #e8e8e8)'
            };
            
            document.getElementById('canvas-container').style.background = backgrounds[state.settings.canvasBg] || backgrounds.light;
        }

        // === EXPORT/IMPORT ===
        document.getElementById('export-btn').addEventListener('click', () => {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                boards: state.boards,
                items: state.items,
                settings: state.settings
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `gridora-export-${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('Exported successfully', 'success');
        });

        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file-input').click();
        });

        document.getElementById('import-file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Import boards
                for (const board of data.boards) {
                    await saveBoard(board);
                }
                
                // Import items
                for (const item of data.items) {
                    await saveItem(item);
                }
                
                // Reload
                state.boards = await loadBoards();
                if (state.boards.length > 0) {
                    await switchBoard(state.boards[0].id);
                }
                
                renderBoardList();
                showToast('Imported successfully', 'success');
            } catch (error) {
                showToast('Import failed: ' + error.message, 'error');
            }
            
            e.target.value = '';
        });

        document.getElementById('clear-board-btn').addEventListener('click', async () => {
            if (!confirm('Clear all items from this board? This cannot be undone.')) return;
            
            for (const item of state.items) {
                await deleteItem(item.id);
            }
            
            state.items = [];
            state.selectedItem = null;
            state.history = [];
            state.historyIndex = -1;
            
            renderCanvas();
            showToast('Board cleared', 'success');
        });

        // === AI ASSISTANT ===
        document.getElementById('ai-btn').addEventListener('click', () => {
            const panel = document.getElementById('ai-panel');
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                generateAISuggestions();
            }
        });

        function generateAISuggestions() {
            const suggestions = [
                {
                    title: 'üìê Grid Layout',
                    desc: 'Create a 3x3 grid of image placeholders',
                    action: () => createGridLayout(3, 3)
                },
                {
                    title: 'üé® Color Palette',
                    desc: 'Generate a complementary color palette',
                    action: () => createColorPalette()
                },
                {
                    title: 'üåà Rainbow Layout',
                    desc: 'Create a rainbow gradient color swatches',
                    action: () => createRainbowLayout()
                },
                {
                    title: 'üìã Note Board',
                    desc: 'Add 5 sticky notes for brainstorming',
                    action: () => createNoteBoard()
                },
                {
                    title: 'üñºÔ∏è Gallery Wall',
                    desc: 'Create asymmetric gallery layout',
                    action: () => createGalleryWall()
                },
                {
                    title: 'üé≠ Mood Theme',
                    desc: 'Generate aesthetic color & text combos',
                    action: () => createMoodTheme()
                },
                {
                    title: '‚ú® Emoji Story',
                    desc: 'Create a visual story with emojis',
                    action: () => createEmojiStory()
                },
                {
                    title: 'üéØ Vision Board',
                    desc: 'Create a goal-oriented vision board',
                    action: () => createVisionBoard()
                }
            ];
            
            const container = document.getElementById('ai-suggestions');
            container.innerHTML = '';
            
            suggestions.forEach(suggestion => {
                const div = document.createElement('div');
                div.className = 'ai-suggestion';
                div.innerHTML = `
                    <div class="ai-suggestion-title">${suggestion.title}</div>
                    <div class="ai-suggestion-desc">${suggestion.desc}</div>
                `;
                div.addEventListener('click', () => {
                    suggestion.action();
                    document.getElementById('ai-panel').classList.remove('open');
                });
                container.appendChild(div);
            });
        }

        async function createGridLayout(rows, cols) {
            const spacing = 20;
            const itemSize = 150;
            const startX = 100;
            const startY = 100;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const item = {
                        id: generateId(),
                        type: 'color',
                        boardId: state.currentBoardId,
                        data: { color: '#e0e0e0' },
                        x: startX + c * (itemSize + spacing),
                        y: startY + r * (itemSize + spacing),
                        width: itemSize,
                        height: itemSize,
                        rotation: 0,
                        zIndex: state.items.length + r * cols + c
                    };
                    
                    state.items.push(item);
                    await saveItem(item);
                }
            }
            
            renderCanvas();
            addToHistory();
            showToast(`${rows}x${cols} grid created`, 'success');
        }

        async function createColorPalette() {
            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#feca57'];
            const startX = 100;
            const startY = 100;
            const size = 120;
            const spacing = 20;
            
            for (let i = 0; i < colors.length; i++) {
                const item = {
                    id: generateId(),
                    type: 'color',
                    boardId: state.currentBoardId,
                    data: { color: colors[i] },
                    x: startX + i * (size + spacing),
                    y: startY,
                    width: size,
                    height: size,
                    rotation: 0,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Color palette created', 'success');
        }

        async function createRainbowLayout() {
            const colors = ['#FF6B6B', '#FFA06B', '#FFD93D', '#6BCF7F', '#6B9AFF', '#9B6BFF', '#FF6BFF'];
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const radius = 200;
            
            for (let i = 0; i < colors.length; i++) {
                const angle = (i / colors.length) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * radius - 60;
                const y = centerY + Math.sin(angle) * radius - 60;
                
                const item = {
                    id: generateId(),
                    type: 'color',
                    boardId: state.currentBoardId,
                    data: { color: colors[i] },
                    x: x,
                    y: y,
                    width: 120,
                    height: 120,
                    rotation: 0,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Rainbow layout created', 'success');
        }

        async function createNoteBoard() {
            const notes = ['Ideas', 'Todo', 'Inspiration', 'Goals', 'Notes'];
            const colors = ['#FFE5B4', '#B4E5FF', '#FFB4E5', '#E5FFB4', '#E5B4FF'];
            const startX = 100;
            const startY = 100;
            
            for (let i = 0; i < notes.length; i++) {
                const item = {
                    id: generateId(),
                    type: 'text',
                    boardId: state.currentBoardId,
                    data: { text: notes[i] },
                    x: startX + (i % 3) * 220,
                    y: startY + Math.floor(i / 3) * 180,
                    width: 200,
                    height: 150,
                    rotation: (Math.random() - 0.5) * 5,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Note board created', 'success');
        }

        async function createGalleryWall() {
            const layouts = [
                { x: 100, y: 100, w: 200, h: 200 },
                { x: 320, y: 100, w: 150, h: 250 },
                { x: 490, y: 100, w: 180, h: 180 },
                { x: 100, y: 320, w: 250, h: 150 },
                { x: 370, y: 300, w: 200, h: 220 }
            ];
            
            for (let i = 0; i < layouts.length; i++) {
                const layout = layouts[i];
                const item = {
                    id: generateId(),
                    type: 'color',
                    boardId: state.currentBoardId,
                    data: { color: '#e0e0e0' },
                    x: layout.x,
                    y: layout.y,
                    width: layout.w,
                    height: layout.h,
                    rotation: 0,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Gallery wall created', 'success');
        }

        async function createMoodTheme() {
            const theme = {
                colors: ['#2C3E50', '#E74C3C', '#ECF0F1'],
                texts: ['Minimalist', 'Bold', 'Clean']
            };
            
            // Add color swatches
            for (let i = 0; i < theme.colors.length; i++) {
                const item = {
                    id: generateId(),
                    type: 'color',
                    boardId: state.currentBoardId,
                    data: { color: theme.colors[i] },
                    x: 100 + i * 160,
                    y: 100,
                    width: 140,
                    height: 140,
                    rotation: 0,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            // Add text notes
            for (let i = 0; i < theme.texts.length; i++) {
                const item = {
                    id: generateId(),
                    type: 'text',
                    boardId: state.currentBoardId,
                    data: { text: theme.texts[i] },
                    x: 100 + i * 160,
                    y: 260,
                    width: 140,
                    height: 80,
                    rotation: 0,
                    zIndex: state.items.length + theme.colors.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Mood theme created', 'success');
        }

        async function createEmojiStory() {
            const emojis = ['üöÄ', 'üí°', 'üéØ', 'üåü', '‚ú®', 'üé®', 'üñåÔ∏è', 'üì±'];
            const startX = 100;
            const startY = 100;
            const spacing = 140;
            
            for (let i = 0; i < emojis.length; i++) {
                const item = {
                    id: generateId(),
                    type: 'emoji',
                    boardId: state.currentBoardId,
                    data: { emoji: emojis[i] },
                    x: startX + (i % 4) * spacing,
                    y: startY + Math.floor(i / 4) * spacing,
                    width: 120,
                    height: 120,
                    rotation: (Math.random() - 0.5) * 10,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Emoji story created', 'success');
        }

        async function createVisionBoard() {
            // Create a vision board with goals and inspiration
            const items = [
                { type: 'text', data: { text: 'My Goals' }, x: 100, y: 100, width: 200, height: 150 },
                { type: 'text', data: { text: 'Inspiration' }, x: 320, y: 100, width: 200, height: 150 },
                { type: 'text', data: { text: 'Action Steps' }, x: 540, y: 100, width: 200, height: 150 },
                { type: 'color', data: { color: '#FF6B6B' }, x: 100, y: 270, width: 120, height: 120 },
                { type: 'color', data: { color: '#4ECDC4' }, x: 240, y: 270, width: 120, height: 120 },
                { type: 'color', data: { color: '#FFE66D' }, x: 380, y: 270, width: 120, height: 120 },
                { type: 'emoji', data: { emoji: 'üéØ' }, x: 520, y: 270, width: 120, height: 120 },
                { type: 'emoji', data: { emoji: '‚ú®' }, x: 660, y: 270, width: 120, height: 120 }
            ];
            
            for (let i = 0; i < items.length; i++) {
                const itemData = items[i];
                const item = {
                    id: generateId(),
                    type: itemData.type,
                    boardId: state.currentBoardId,
                    data: itemData.data,
                    x: itemData.x,
                    y: itemData.y,
                    width: itemData.width,
                    height: itemData.height,
                    rotation: 0,
                    zIndex: state.items.length + i
                };
                
                state.items.push(item);
                await saveItem(item);
            }
            
            renderCanvas();
            addToHistory();
            showToast('Vision board created', 'success');
        }

        // === SIDEBAR ===
        document.getElementById('boards-btn').addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('open');
        });

        document.getElementById('new-board-btn').addEventListener('click', () => {
            openModal('board-modal');
        });

        document.getElementById('create-board-btn').addEventListener('click', async () => {
            const name = document.getElementById('board-name-input').value;
            await createBoard(name || 'Untitled Board');
            document.getElementById('board-name-input').value = '';
            closeModal('board-modal');
        });

        // === INITIALIZATION ===
        async function init() {
            try {
                await initDB();
                
                // Load settings
                const savedSettings = await loadSettings();
                if (savedSettings) {
                    state.settings = savedSettings;
                    applyTheme();
                    applyCanvasBackground();
                    document.getElementById('theme-select').value = state.settings.theme;
                    document.getElementById('canvas-bg-select').value = state.settings.canvasBg;
                    document.getElementById('grid-toggle').checked = state.settings.showGrid;
                    document.getElementById('snap-toggle').checked = state.settings.snapEnabled;
                    document.getElementById('canvas').classList.toggle('dot-grid', state.settings.showGrid);
                } else {
                    applyTheme();
                    applyCanvasBackground();
                }
                
                // Load boards
                state.boards = await loadBoards();
                
                if (state.boards.length === 0) {
                    // Create default board
                    await createBoard('My First Board');
                } else {
                    // Load first board
                    await switchBoard(state.boards[0].id);
                }
                
                renderBoardList();
                showToast('Welcome to Gridora! ‚ú®', 'success');
            } catch (error) {
                console.error('Initialization error:', error);
                showToast('Error loading app: ' + error.message, 'error');
            }
        }

        // Start the app
        init();

        // Prevent accidental page navigation
        window.addEventListener('beforeunload', (e) => {
            if (state.items.length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>
