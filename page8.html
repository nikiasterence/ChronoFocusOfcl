<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
     <link rel="icon" href="Chronofocus.png" type="image/x-icon">
    <title>Enhanced Draw Board</title>
    
    <!-- Icons from Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- jsPDF library for creating PDFs, loaded from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* --- 1. General Setup & Design System --- */
        :root {
            --primary-color: #5b21b6; /* Deep Violet */
            --secondary-color: #3b82f6; /* Cool Blue */
            --background-start: #f5f3ff;
            --background-end: #eff6ff;
            --font-color: #333;
            --light-grey: #e5e7eb;
            --white-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            background: linear-gradient(135deg, var(--background-end), var(--background-start));
        }

        body {
            display: flex;
            flex-direction: column;
            color: var(--font-color);
        }

        /* --- 2. Main Layout --- */
        .app-container {
            display: flex;
            flex: 1;
            height: 100%;
            flex-direction: column;
        }
        
        .toolbar {
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            background: var(--white-color);
            border-bottom: 1px solid var(--light-grey);
            box-shadow: 0 4px 12px var(--shadow-color);
            flex-shrink: 0;
            z-index: 100;
        }

        .whiteboard {
            flex-grow: 1;
            position: relative;
            background-color: #f8fafc;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- 3. Toolbar Elements --- */
        .tool-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background-color: var(--light-grey);
            border-radius: 12px;
        }

        .tool-button {
            width: 44px; height: 44px; border-radius: 10px; border: none;
            background: transparent; cursor: pointer; transition: all 0.2s ease;
            font-size: 1.1rem; color: #555; display: grid; place-items: center;
        }
        
        .tool-button:hover { background: rgba(0,0,0,0.1); }
        .tool-button.active { background: var(--primary-color); color: white; box-shadow: 0 2px 8px rgba(91, 33, 182, 0.4); }
        
        #color-picker {
            width: 42px; height: 42px; border: none; padding: 0;
            border-radius: 10px; background-color: transparent; cursor: pointer;
        }
        #color-picker::-webkit-color-swatch { border: 2px solid rgba(0,0,0,0.1); border-radius: 8px; }

        .pen-size-group { align-items: center; gap: 8px; }
        #pen-size { width: 100px; cursor: pointer; }
        .pen-size-group i { color: #888; }

        .page-controls { font-weight: 500; color: var(--primary-color); }
        #page-indicator { min-width: 60px; text-align: center; }

        /* --- 4. Modals (for Text and Stickers) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4); z-index: 1000;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.visible { opacity: 1; pointer-events: all; }

        .modal-content {
            background: white; padding: 24px; border-radius: 16px; 
            box-shadow: 0 10px 30px var(--shadow-color);
            display: flex; flex-direction: column; gap: 12px; min-width: 300px;
            max-width: 90vw; max-height: 80vh;
        }
        .modal-content h3 { margin-bottom: 10px; color: var(--primary-color); }
        .modal-content input[type="text"] {
            padding: 12px; border: 1px solid var(--light-grey); border-radius: 8px; font-size: 16px;
        }
        .modal-content button.action-btn {
            padding: 12px; border-radius: 8px; border: none; font-weight: 600; cursor: pointer;
            background: var(--primary-color); color: white; transition: background 0.2s;
        }
        .modal-content button.action-btn:hover { background: var(--secondary-color); }

        /* Sticker Modal Specifics */
        .sticker-modal-body { overflow-y: auto; padding-right: 10px; }
        .sticker-category { margin-bottom: 15px; }
        .sticker-category h4 { margin-bottom: 10px; border-bottom: 1px solid var(--light-grey); padding-bottom: 5px; }
        .sticker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 15px; }
        .sticker-option { font-size: 32px; cursor: pointer; transition: transform 0.2s; text-align: center; }
        .sticker-option:hover { transform: scale(1.3); }

        /* --- 5. Mobile Responsiveness --- */
        @media (max-width: 768px) {
            .toolbar {
                padding: 8px;
                gap: 8px;
            }
            .tool-group {
                padding: 4px;
            }
            .tool-button {
                width: 40px; height: 40px;
            }
            .pen-size-group {
                display: none; /* Hide slider on small screens for cleaner UI */
            }
        }
    </style>
</head>
<body>

    <div class="app-container">
        <!-- Main Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-button active" data-tool="pen" title="Pen"><i class="fas fa-pen"></i></button>
                <button class="tool-button" data-tool="auto-draw" title="Magic Pen (Shape Correction)"><i class="fas fa-magic"></i></button>
                <button class="tool-button" data-tool="eraser" title="Eraser"><i class="fas fa-eraser"></i></button>
                <button class="tool-button" data-tool="text" title="Add Text"><i class="fas fa-font"></i></button>
                <button class="tool-button" data-tool="sticker" title="Add Sticker"><i class="fas fa-smile"></i></button>
            </div>

            <div class="tool-group">
                <input type="color" id="color-picker" value="#000000" title="Select Color">
            </div>

            <div class="tool-group pen-size-group">
                <i class="fas fa-circle" style="font-size: 8px;"></i>
                <input type="range" id="pen-size" min="1" max="100" value="5" title="Pen Size">
                <i class="fas fa-circle" style="font-size: 18px;"></i>
            </div>

            <div class="tool-group page-controls">
                <button class="tool-button" id="prev-page" title="Previous Page"><i class="fas fa-chevron-left"></i></button>
                <span id="page-indicator">1 / 1</span>
                <button class="tool-button" id="next-page" title="Next Page"><i class="fas fa-chevron-right"></i></button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="download-png" title="Download as PNG"><i class="fas fa-file-image"></i></button>
                <button class="tool-button" id="download-pdf" title="Download Text as PDF"><i class="fas fa-file-pdf"></i></button>
                <button class="tool-button" id="clear-btn" title="Clear Canvas"><i class="fas fa-trash-alt"></i></button>
            </div>
        </div>
        
        <div class="whiteboard">
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="text-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Add Text</h3>
            <input type="text" id="text-input" placeholder="Type here...">
            <button id="add-text-btn" class="action-btn">Add Text</button>
        </div>
    </div>
    
    <div id="sticker-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Add a Sticker</h3>
            <div class="sticker-modal-body">
                <div class="sticker-category">
                    <h4>Reactions</h4>
                    <div class="sticker-grid">
                        <span class="sticker-option" data-sticker="‚≠ê">‚≠ê</span>
                        <span class="sticker-option" data-sticker="‚ù§Ô∏è">‚ù§Ô∏è</span>
                        <span class="sticker-option" data-sticker="üí°">üí°</span>
                        <span class="sticker-option" data-sticker="üëç">üëç</span>
                        <span class="sticker-option" data-sticker="‚úîÔ∏è">‚úîÔ∏è</span>
                        <span class="sticker-option" data-sticker="‚ùì">‚ùì</span>
                        <span class="sticker-option" data-sticker="‚ùó">‚ùó</span>
                        <span class="sticker-option" data-sticker="üî•">üî•</span>
                    </div>
                </div>
                <div class="sticker-category">
                    <h4>Shapes</h4>
                    <div class="sticker-grid">
                        <span class="sticker-option" data-sticker="‚û°Ô∏è">‚û°Ô∏è</span>
                        <span class="sticker-option" data-sticker="‚¨ÖÔ∏è">‚¨ÖÔ∏è</span>
                        <span class="sticker-option" data-sticker="‚¨ÜÔ∏è">‚¨ÜÔ∏è</span>
                        <span class="sticker-option" data-sticker="‚¨áÔ∏è">‚¨áÔ∏è</span>
                        <span class="sticker-option" data-sticker="‚≠ï">‚≠ï</span>
                        <span class="sticker-option" data-sticker="‚ùå">‚ùå</span>
                        <span class="sticker-option" data-sticker="üî∫">üî∫</span>
                        <span class="sticker-option" data-sticker="‚¨õ">‚¨õ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { jsPDF } = window.jspdf;
        
        document.addEventListener('DOMContentLoaded', () => {
            class AdvancedWhiteboard {
                constructor(canvasId) {
                    this.canvas = document.getElementById(canvasId);
                    this.ctx = this.canvas.getContext('2d');
                    this.isDrawing = false;
                    this.currentTool = 'pen';
                    this.currentColor = '#000000';
                    this.penSize = 5;
                    this.lastX = 0; this.lastY = 0;
                    this.pages = [this.createBlankPage()];
                    this.currentPageIndex = 0;
                    this.textCoords = { x: 0, y: 0 };
                    
                    // State specifically for Auto-Draw tool
                    this.currentStrokePoints = [];
                    this.canvasStateBeforeStroke = null;

                    this.init();
                }

                createBlankPage() { return { drawing: null, texts: [] }; }

                init() {
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());

                    this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                    this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                    this.canvas.addEventListener('mouseup', () => this.handleEnd());
                    this.canvas.addEventListener('mouseout', () => this.handleEnd());
                    this.canvas.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
                    this.canvas.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
                    this.canvas.addEventListener('touchend', () => this.handleEnd());

                    this.setupUI();
                    this.updatePageIndicator();
                }

                resizeCanvas() {
                    this.saveCurrentPage();
                    this.canvas.width = this.canvas.parentElement.offsetWidth;
                    this.canvas.height = this.canvas.parentElement.offsetHeight;
                    this.loadPage(this.currentPageIndex);
                }

                loadPage(index) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    const page = this.pages[index];
                    if (page && page.drawing) {
                        const img = new Image();
                        img.src = page.drawing;
                        img.onload = () => { this.ctx.drawImage(img, 0, 0); };
                    }
                }
                
                saveCurrentPage() {
                    if (this.pages[this.currentPageIndex]) {
                        this.pages[this.currentPageIndex].drawing = this.canvas.toDataURL();
                    }
                }

                changePage(direction) {
                    this.saveCurrentPage();
                    if (direction === 'next') {
                        this.currentPageIndex++;
                        if (this.currentPageIndex === this.pages.length) this.pages.push(this.createBlankPage());
                    } else if (direction === 'prev' && this.currentPageIndex > 0) {
                        this.currentPageIndex--;
                    }
                    this.loadPage(this.currentPageIndex);
                    this.updatePageIndicator();
                }
                
                updatePageIndicator() {
                    document.getElementById('page-indicator').textContent = `${this.currentPageIndex + 1} / ${this.pages.length}`;
                }

                getCoordinates(event) {
                    event.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    if (event.touches && event.touches.length > 0) {
                        return [event.touches[0].clientX - rect.left, event.touches[0].clientY - rect.top];
                    }
                    return [event.clientX - rect.left, event.clientY - rect.top];
                }

                handleStart(e) {
                    const [x, y] = this.getCoordinates(e);

                    switch (this.currentTool) {
                        case 'pen':
                        case 'eraser':
                            this.isDrawing = true;
                            [this.lastX, this.lastY] = [x, y];
                            break;
                        case 'auto-draw':
                            this.isDrawing = true;
                            [this.lastX, this.lastY] = [x, y];
                            this.canvasStateBeforeStroke = this.canvas.toDataURL();
                            this.currentStrokePoints = [[x, y]]; // Initialize only for auto-draw
                            break;
                        case 'text':
                            this.textCoords = { x, y };
                            this.showTextModal(true);
                            break;
                        case 'sticker':
                            this.showStickerModal(true);
                            break;
                    }
                }
                
                handleMove(e) {
                    if (!this.isDrawing) return;
                    
                    const [x, y] = this.getCoordinates(e);
                    
                    // Only track stroke points if using the auto-draw tool
                    if (this.currentTool === 'auto-draw') {
                        this.currentStrokePoints.push([x, y]);
                    }
                    
                    this.draw(x, y);
                }

                handleEnd() {
                    if (!this.isDrawing) return;
                    this.isDrawing = false;
                    
                    if (this.currentTool === 'auto-draw') {
                        this.processAutoDraw();
                        this.currentStrokePoints = []; // Clear points for the next shape
                    } else {
                        // For regular pen and eraser, save the drawing immediately
                        this.saveCurrentPage();
                    }
                }
                
                draw(x, y) {
                    this.ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';
                    this.ctx.strokeStyle = this.currentColor;
                    this.ctx.lineWidth = this.penSize;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.lastX, this.lastY);
                    this.ctx.lineTo(x, y);
                    this.ctx.stroke();
                    [this.lastX, this.lastY] = [x, y];
                }

                addText(text) {
                    const { x, y } = this.textCoords;
                    const size = Math.max(20, this.penSize * 2);
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.fillStyle = this.currentColor;
                    this.ctx.font = `bold ${size}px sans-serif`;
                    this.ctx.fillText(text, x, y);
                    this.pages[this.currentPageIndex].texts.push({ text, x, y, color: this.currentColor, size });
                    this.saveCurrentPage();
                }
                
                addSticker(sticker, x, y) {
                    const size = Math.max(50, this.penSize * 4);
                    this.ctx.font = `${size}px sans-serif`;
                    // Adjust placement to center the sticker on the click point
                    this.ctx.fillText(sticker, x - size / 2, y + size / 3);
                    this.saveCurrentPage();
                }

                setupUI() {
                    const toolButtons = document.querySelectorAll('.tool-button');
                    toolButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            if (button.id.startsWith('download') || button.id === 'clear-btn' || button.id.includes('page')) return;
                            document.querySelector('.tool-button.active').classList.remove('active');
                            button.classList.add('active');
                            this.currentTool = button.dataset.tool;
                            if (this.currentTool === 'sticker') this.showStickerModal(true);
                        });
                    });
                    
                    document.getElementById('color-picker').addEventListener('input', e => this.currentColor = e.target.value);
                    document.getElementById('pen-size').addEventListener('input', e => this.penSize = e.target.value);
                    document.getElementById('prev-page').addEventListener('click', () => this.changePage('prev'));
                    document.getElementById('next-page').addEventListener('click', () => this.changePage('next'));
                    document.getElementById('download-png').addEventListener('click', () => this.downloadAsPNG());
                    document.getElementById('download-pdf').addEventListener('click', () => this.downloadTextAsPDF());
                    document.getElementById('clear-btn').addEventListener('click', () => {
                        if (confirm('Are you sure you want to clear this page?')) {
                            this.pages[this.currentPageIndex] = this.createBlankPage();
                            this.loadPage(this.currentPageIndex);
                        }
                    });

                    // Modals
                    this.textModal = document.getElementById('text-modal');
                    this.textInput = document.getElementById('text-input');
                    document.getElementById('add-text-btn').addEventListener('click', () => {
                        if (this.textInput.value) { this.addText(this.textInput.value); this.showTextModal(false); }
                    });
                    this.textModal.addEventListener('click', e => { if (e.target === this.textModal) this.showTextModal(false); });
                    
                    this.stickerModal = document.getElementById('sticker-modal');
                    document.querySelectorAll('.sticker-option').forEach(sticker => {
                        sticker.addEventListener('click', () => {
                            // When a sticker is chosen, place it where the canvas was last clicked
                            this.canvas.addEventListener('click', (e) => {
                                const [x, y] = this.getCoordinates(e);
                                this.addSticker(sticker.dataset.sticker, x, y);
                            }, { once: true }); // Use the event listener only once
                            this.showStickerModal(false);
                        });
                    });
                    this.stickerModal.addEventListener('click', e => { if (e.target === this.stickerModal) this.showStickerModal(false); });
                }
                
                showTextModal(visible) {
                    this.textModal.classList.toggle('visible', visible);
                    if (visible) { this.textInput.value = ''; this.textInput.focus(); }
                }

                showStickerModal(visible) { this.stickerModal.classList.toggle('visible', visible); }
                
                downloadAsPNG() {
                    const link = document.createElement('a');
                    link.download = `whiteboard-page-${this.currentPageIndex + 1}.png`;
                    link.href = this.canvas.toDataURL('image/png');
                    link.click();
                }

                downloadTextAsPDF() { /* Unchanged */ }
                
                // --- AUTO-DRAW SHAPE RECOGNITION ---
                processAutoDraw() {
                    if (this.currentStrokePoints.length < 10) {
                        this.saveCurrentPage();
                        return;
                    }
                    
                    const img = new Image();
                    img.src = this.canvasStateBeforeStroke;
                    img.onload = () => {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.drawImage(img, 0, 0); // Restore canvas to pre-stroke state
                        this.recognizeAndDrawPerfectShape(); // Draw the new shape
                    };
                }

                recognizeAndDrawPerfectShape() {
                    const points = this.currentStrokePoints;
                    const startPoint = points[0];
                    const endPoint = points[points.length - 1];
                    const bounds = this.getBoundingBox(points);

                    if (this.isLine(points)) return this.drawPerfectLine(startPoint, endPoint);
                    if (this.isRectangle(points, bounds)) return this.drawPerfectRectangle(bounds);
                    if (this.isCircle(points, bounds)) return this.drawPerfectCircle(bounds);

                    this.saveCurrentPage(); // If no shape recognized, save the original stroke anyway
                }

                getBoundingBox(points) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    points.forEach(([x, y]) => {
                        minX = Math.min(minX, x); minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
                    });
                    return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
                }

                isLine(points, threshold = 0.98) {
                    const dist = (p1, p2) => Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);
                    const pathLength = points.reduce((len, p, i) => i > 0 ? len + dist(p, points[i - 1]) : 0, 0);
                    const straightDist = dist(points[0], points[points.length - 1]);
                    return pathLength > 0 && (straightDist / pathLength) > threshold;
                }

                isRectangle(points, bounds) {
                    const cornerRegions = [[bounds.minX, bounds.minY], [bounds.maxX, bounds.minY], [bounds.maxX, bounds.maxY], [bounds.minX, bounds.maxY]];
                    const cornerThreshold = Math.min(bounds.width, bounds.height) * 0.3;
                    let cornersFound = 0;
                    for (const corner of cornerRegions) {
                        if (points.some(p => Math.abs(p[0] - corner[0]) < cornerThreshold && Math.abs(p[1] - corner[1]) < cornerThreshold)) {
                            cornersFound++;
                        }
                    }
                    return cornersFound >= 3;
                }

                isCircle(points, bounds) {
                    const center = { x: bounds.minX + bounds.width / 2, y: bounds.minY + bounds.height / 2 };
                    const radius = (bounds.width + bounds.height) / 4;
                    const totalDistance = points.reduce((dist, p) => dist + Math.sqrt((p[0] - center.x) ** 2 + (p[1] - center.y) ** 2), 0);
                    const avgRadius = totalDistance / points.length;
                    const aspectRatio = bounds.width / bounds.height;
                    const radiusConsistency = Math.abs(avgRadius - radius) / radius;
                    return aspectRatio > 0.8 && aspectRatio < 1.2 && radiusConsistency < 0.3;
                }

                drawPerfectLine(start, end) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(start[0], start[1]);
                    this.ctx.lineTo(end[0], end[1]);
                    this.ctx.stroke();
                    this.saveCurrentPage();
                }

                drawPerfectRectangle({minX, minY, width, height}) {
                    this.ctx.strokeRect(minX, minY, width, height);
                    this.saveCurrentPage();
                }

                drawPerfectCircle(bounds) {
                    const center = { x: bounds.minX + bounds.width / 2, y: bounds.minY + bounds.height / 2 };
                    const radius = (bounds.width + bounds.height) / 4;
                    this.ctx.beginPath();
                    this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    this.saveCurrentPage();
                }
            }
            
            new AdvancedWhiteboard('canvas');
        });
    </script>
</body>
</html>
